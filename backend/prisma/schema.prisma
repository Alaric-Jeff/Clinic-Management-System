// This is your Prisma schema file
// Learn more at: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---------------- ENUMS ----------------

// Roles for staff accounts
enum Role {
  admin
  encoder
}

// Patient gender
enum Gender {
  male
  female
}

// Categories for lab services
enum ServiceCategory {
  hematology
  bacteriology
  clinical_microscopy
  twenty_four_hour_urine_test
  serology_immunology
  clinical_chemistry
  electrolytes
  vaccine
  histopathology
  to_be_read_by_pathologist
  tumor_markers
  thyroid_function_test
  hormones
  hepatitis
  enzymes
  others
}

// Status for accounts
enum AccountStatus {
  activated
  deactivated
  pending
}

// Status for medical documentation progress
enum DocumentationStatus {
  complete
  incomplete
  draft
}

enum PaymentStatus {
  paid
  unpaid
  partially_paid
}

// ---------------- MODELS ----------------

model Account {
  id           String        @id @default(cuid())
  firstName    String
  lastName     String
  middleName   String?       @default("N/A")
  email        String        @unique
  password     String
  role         Role          @default(encoder)
  status       AccountStatus @default(pending)
  
  // Relations
  medicalDocumentations MedicalDocumentation[]

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@map("accounts")
  @@index([email])
  @@index([role])
  @@index([status])
}

model Doctors {
  id String @id @default(cuid())
  firstName String
  lastName String
  middleInitial String?
  medicalDocumentations MedicalDocumentation[]

  @@map("doctors")
}

model Patient {
  id                  String    @id @default(cuid())
  firstName           String
  lastName            String
  middleName          String?   @default("N/A")
  birthDate           DateTime
  gender              Gender    
  csdIdOrPwdId        String?
  mobileNumber        String?
  residentialAddress  String?
  isArchived          Boolean   @default(false)
  
  // Denormalized audit fields only (no relations needed!)
  createdByName       String   
  updatedByName       String?    
  createdByRole       Role     
  updatedByRole       Role?   
  
  medicalDocumentations MedicalDocumentation[]
  
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@map("patients")
  @@index([isArchived])
  @@index([createdAt])
  @@index([lastName])
  @@index([gender])   
}

model Service {
  id              String          @id @default(cuid())
  name            String          @unique
  category        ServiceCategory
  price           Float
  isActivated     Boolean         @default(true)
  isAvailable     Boolean         @default(true)
  
  createdByName   String?        
  updatedByName   String?      
  createdByRole   Role?     
  updatedByRole   Role?       
  
  // Relations
  billedServices  BilledService[]
  serviceDailyAnalytics ServiceDailyAnalytics[]
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@map("services")
  @@index([category])
  @@index([isActivated])
  @@index([name])
}

model MedicalDocumentation {
  id           String   @id @default(cuid())
  patientId    String
  createdById  String
  admittedById String? 
  
  // Denormalized fields for UI display
  createdByName    String
  createdByRole    Role
  admittedByName   String?
  lastUpdatedByName String?
  lastUpdatedByRole Role?
  
  assessment   String?
  diagnosis    String?
  treatment    String?
  prescription String?
  
  status       DocumentationStatus @default(draft)
  
  patient      Patient @relation(fields: [patientId], references: [id])
  creator      Account @relation(fields: [createdById], references: [id])
  admittedBy   Doctors? @relation(fields: [admittedById], references: [id])
  
  medicalBill  MedicalBill?
  auditLogs    DocumentAuditLog[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("medical_documentations")
  @@index([patientId])
  @@index([createdById])
  @@index([admittedById]) 
  @@index([status])
}

// Bridge table between MedicalBill and Service
// This keeps services independent - if a service is deleted, 
// the billing record remains with the snapshot of service details
model BilledService {
  id                String   @id @default(cuid())
  medicalBillId     String
  serviceId         String?  // Nullable - can be null if service was deleted
  
  // Snapshot of service details at time of billing
  // This preserves the bill even if the service is modified/deleted later
  serviceName       String
  serviceCategory   ServiceCategory
  servicePriceAtTime Float    // Price at the time of billing
  quantity          Int      @default(1)
  subtotal          Float    // quantity * servicePriceAtTime
  
  medicalBill       MedicalBill @relation(fields: [medicalBillId], references: [id], onDelete: Cascade)
  service           Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  
  createdAt         DateTime @default(now())
  
  @@map("billed_services")
  @@index([medicalBillId])
  @@index([serviceId])
}

model MedicalBill {
  id                    String        @id @default(cuid())
  medicalDocumentationId String       @unique // One-to-one with medical documentation
  
  totalAmount           Float         @default(0.00)
  amountPaid            Float         @default(0.00)
  balance               Float         @default(0.00)
  paymentStatus         PaymentStatus @default(unpaid)
  
  // Audit trail
  createdByName         String
  createdByRole         Role
  lastUpdatedByName     String?
  lastUpdatedByRole     Role?
  
  // Relations
  medicalDocumentation  MedicalDocumentation @relation(fields: [medicalDocumentationId], references: [id])
  billedServices        BilledService[]
  paymentHistory        PaymentHistory[]
  
  notes                 String?       // For payment arrangements, discounts, special notes
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  
  @@map("medical_bills")
  @@index([medicalDocumentationId])
  @@index([paymentStatus])
  @@index([createdAt])
}

// Track payment history for partial payments and audit trail
model PaymentHistory {
  id              String      @id @default(cuid())
  medicalBillId   String
  
  amountPaid      Float
  paymentMethod   String?     // cash, card, insurance, etc.
  notes           String?     // For special cases, trusted patient arrangements
  
  recordedByName  String
  recordedByRole  Role
  
  medicalBill     MedicalBill @relation(fields: [medicalBillId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime    @default(now())
  
  @@map("payment_history")
  @@index([medicalBillId])
  @@index([createdAt])
}

// ---------------- ANALYTICS MODELS ----------------

// Daily aggregated sales data for fast analytics and forecasting
model DailySalesAnalytics {
  id                String          @id @default(cuid())
  date              DateTime        @db.Date // Only date, no time
  
  // Overall metrics
  totalRevenue      Float           @default(0.00)
  totalBills        Int             @default(0)
  totalServices     Int             @default(0)
  paidBills         Int             @default(0)
  unpaidBills       Int             @default(0)
  partiallyPaidBills Int            @default(0)
  averageBillAmount Float           @default(0.00)
  
  // Relations
  serviceAnalytics  ServiceDailyAnalytics[]
  categoryAnalytics CategoryDailyAnalytics[]
  
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  @@unique([date])
  @@map("daily_sales_analytics")
  @@index([date])
}

// Per-service daily performance for identifying top/bottom performers
model ServiceDailyAnalytics {
  id                String          @id @default(cuid())
  dailyAnalyticsId  String
  serviceId         String?         // Nullable in case service is deleted
  
  // Snapshot of service info
  serviceName       String
  serviceCategory   ServiceCategory
  
  // Metrics
  totalRevenue      Float           @default(0.00)
  quantitySold      Int             @default(0)
  averagePrice      Float           @default(0.00) // In case price changed during the day
  
  dailyAnalytics    DailySalesAnalytics @relation(fields: [dailyAnalyticsId], references: [id], onDelete: Cascade)
  service           Service? @relation(fields: [serviceId], references: [id], onDelete: SetNull)
  
  createdAt         DateTime        @default(now())
  
  @@unique([dailyAnalyticsId, serviceName]) // One record per service per day
  @@map("service_daily_analytics")
  @@index([dailyAnalyticsId])
  @@index([serviceId])
  @@index([serviceName])
}

// Per-category daily performance for category-level insights
model CategoryDailyAnalytics {
  id                String          @id @default(cuid())
  dailyAnalyticsId  String
  category          ServiceCategory
  
  // Metrics
  totalRevenue      Float           @default(0.00)
  totalServices     Int             @default(0) // Count of different services in this category
  quantitySold      Int             @default(0) // Total quantity across all services
  
  dailyAnalytics    DailySalesAnalytics @relation(fields: [dailyAnalyticsId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime        @default(now())
  
  @@unique([dailyAnalyticsId, category]) // One record per category per day
  @@map("category_daily_analytics")
  @@index([dailyAnalyticsId])
  @@index([category])
}

// ---------------- AUDIT LOG MODEL ----------------

// Tracks changes to medical documentation - can be reviewed and deleted by admin
model DocumentAuditLog {
  id                      String   @id @default(cuid())
  medicalDocumentationId  String
  
  action                  String   // "created", "updated", "status_changed"
  fieldsChanged           String   // JSON string or comma-separated: "diagnosis,treatment"
  previousData            String?  // JSON string of old values
  newData                 String?  // JSON string of new values
  
  changedByName           String
  changedByRole           Role
  
  medicalDocumentation    MedicalDocumentation @relation(fields: [medicalDocumentationId], references: [id], onDelete: Cascade)
  
  createdAt               DateTime @default(now())
  
  @@map("document_audit_logs")
  @@index([medicalDocumentationId])
  @@index([createdAt])
  @@index([changedByName])
}

// ---------------- DOCUMENTATION NOTES ----------------
/*
SIMPLIFIED PAYMENT SYSTEM:
- Medical documentation can be edited with full audit trail via DocumentAuditLog.

- At least one field (assessment, diagnosis, treatment, or prescription) must be filled.
  (ENFORCE in app layer with validation OR via a Postgres CHECK constraint)

- Patient records are never deleted, only archived (isArchived flag).

- Accounts start as pending and must be activated before use.

- Services have unique names, can be activated/deactivated, and tied to categories for analytics.

- Patient audit trail uses denormalized fields for performance (no Account relations needed).

- Services are standalone entities with denormalized audit fields for performance.

- Gender field added for patient demographics and reporting.

- MedicalDocumentation uses denormalized fields (createdByName, createdByRole, etc.) for UI display
  while keeping ID references for legal compliance and data integrity.

- BilledService acts as a snapshot: When a service is billed, its details (name, category, price) 
  are copied to preserve billing history even if the service is later modified or deleted.

SIMPLIFIED PAYMENT TRACKING:
- MedicalBill tracks current payment state (totalAmount, amountPaid, balance, paymentStatus)
- PaymentHistory records every payment transaction for complete audit trail
- Use MedicalBill.notes for payment arrangements (e.g., "Will pay Oct 20 after pension")
- PaymentStatus automatically updates based on amountPaid vs totalAmount
- No need for separate PaymentResolution table - simpler and more maintainable

PAYMENT WORKFLOW:
1. Create bill with initial paymentStatus (paid/unpaid/partially_paid)
2. Record payments in PaymentHistory
3. Update MedicalBill status and amounts automatically
4. Use notes field for special arrangements or installment plans

ANALYTICS SYSTEM:
- DailySalesAnalytics: Aggregated daily metrics (total revenue, bills, payment status distribution)
  - Updated via background job or trigger when payments are made
  - Enables fast querying without scanning all transactions
  
- ServiceDailyAnalytics: Per-service performance tracking
  - Shows which services generate the most revenue
  - Tracks quantity sold and average price
  - Useful for identifying top/bottom performers
  
- CategoryDailyAnalytics: Per-category performance tracking
  - Aggregate metrics by service category
  - Shows which lab test categories are most utilized
  
ANALYTICS USAGE:
- Daily data is pre-aggregated for performance
- Weekly metrics: Query 7 days of DailySalesAnalytics and SUM/AVG
- Monthly metrics: Query 30 days of DailySalesAnalytics and SUM/AVG
- Forecasting with simple-statistics: Export daily revenue time series for trend analysis
- Service optimization: Compare ServiceDailyAnalytics to identify underperforming services
- Category analysis: Use CategoryDailyAnalytics to understand which test types drive revenue

IMPLEMENTATION NOTES:
- Run daily aggregation job (cron/scheduled task) to populate analytics tables
- Alternative: Use database triggers on PaymentHistory to update analytics in real-time
- Keep raw data in MedicalBill/BilledService for detailed auditing
- Use analytics tables for dashboards and reports (much faster than aggregating raw data)

AUDIT LOG SYSTEM:
- DocumentAuditLog: Tracks all changes to medical documentation
  - Records what changed, old/new values, who made the change
  - Can be reviewed and deleted by admin to save memory
  - Provides transparency and accountability without complex versioning
  - Store data as JSON for flexibility (fieldsChanged, previousData, newData)
  
AUDIT LOG USAGE:
- Automatically create log entry when documentation is updated
- Admin can review logs and delete old/reviewed entries
- Useful for dispute resolution and quality control
- Balances compliance needs with practical memory management
*/